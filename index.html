<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>One‑File Arcade</title>
  <style>
    :root{
      --bg:#1c1e26;--fg:#eee;--accent:#3f51b5;--card-bg:#252833;
      --btn-bg:#2f3240;--btn-hover:#434764;--radius:8px;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;min-height:100vh;display:flex;flex-direction:column;}
    nav{display:flex;justify-content:center;background:var(--card-bg);padding:.5rem;gap:.5rem;position:sticky;top:0;z-index:10;box-shadow:0 2px 4px rgba(0,0,0,0.5);}
    nav button{background:var(--btn-bg);border:none;color:var(--fg);padding:.5rem 1rem;border-radius:var(--radius);cursor:pointer;font-size:1rem;transition:background .2s,color .2s;}
    nav button:hover,nav button.active{background:var(--accent);color:#fff;}
    main{flex:1;display:flex;align-items:center;justify-content:center;padding:1rem;}
    section{display:none;width:100%;max-width:700px;margin:auto;}
    section.active{display:block;}
    .card-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:1rem;margin-top:1.5rem;}
    .card{background:var(--card-bg);border-radius:var(--radius);padding:1rem;cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:background .3s;min-height:100px;}
    .card:hover{background:var(--btn-hover);} /* lighten on hover */
    .clock{font-size:3rem;font-weight:600;text-align:center;margin-top:2rem;letter-spacing:0.1rem;}
    .subtext{font-size:1rem;text-align:center;margin-top:.5rem;color:#aaa;}
    canvas{background:var(--card-bg);border-radius:var(--radius);}
    #flappyCanvas{width:100%;height:auto;display:block;margin:auto;}
    .cps-area{background:var(--card-bg);border-radius:var(--radius);padding:2rem;text-align:center;user-select:none;cursor:pointer;}
    .cps-area.active{background:var(--accent);} /* highlight when active */
    .stat{margin-top:1rem;font-size:1.2rem;text-align:center;}
    .stat small{display:block;font-size:.8rem;color:#aaa;margin-top:.25rem;}
    .controls{display:flex;justify-content:center;gap:1rem;margin-top:1rem;}
    .controls button{background:var(--accent);border:none;color:#fff;padding:.5rem 1rem;border-radius:var(--radius);cursor:pointer;font-size:1rem;}
    .controls button.secondary{background:var(--btn-bg);color:var(--fg);} /* for secondary actions */
    .hidden{display:none!important;}
  </style>
</head>
<body>
  <nav id="nav">
    <button data-target="home" class="active">Home</button>
    <button data-target="flappy">Flappy</button>
    <button data-target="cps">CPS</button>
    <button data-target="aim">Aim</button>
    <button data-target="audio">Visualizer</button>
  </nav>
  <main>
    <!-- Home Section -->
    <section id="home" class="active">
      <div class="clock" id="clock">--:--:--</div>
      <div class="subtext">Welcome! Choose a mini‑game below.</div>
      <div class="card-grid">
        <div class="card" data-target="flappy"><strong>Flappy Bird</strong><div class="subtext">Tap/space to fly!</div></div>
        <div class="card" data-target="cps"><strong>CPS Tester</strong><div class="subtext">Test your clicks per second</div></div>
        <div class="card" data-target="aim"><strong>Aim Trainer</strong><div class="subtext">Hit 30 targets fast</div></div>
        <div class="card" data-target="audio"><strong>Audio Visualizer</strong><div class="subtext">See your sound</div></div>
      </div>
    </section>
    <!-- Flappy Bird Section -->
    <section id="flappy">
      <h2>Flappy Bird</h2>
      <canvas id="flappyCanvas" width="600" height="400"></canvas>
      <div class="stat" id="flappyStats"></div>
      <div class="controls">
        <button id="flappyStart">Start</button>
        <button id="flappyPause" class="secondary">Pause</button>
        <button id="flappyReset" class="secondary">Reset</button>
      </div>
    </section>
    <!-- CPS Tester Section -->
    <section id="cps">
      <h2>CPS Tester</h2>
      <div class="cps-area" id="cpsArea">Click to start</div>
      <div class="stat" id="cpsStats"></div>
    </section>
    <!-- Aim Trainer Section -->
    <section id="aim">
      <h2>Aim Trainer</h2>
      <canvas id="aimCanvas"></canvas>
      <div class="stat" id="aimStats"></div>
      <div class="controls">
        <button id="aimStart">Start</button>
        <button id="aimReset" class="secondary">Reset</button>
      </div>
    </section>
    <!-- Audio Visualizer Section -->
    <section id="audio">
      <h2>Audio Visualizer</h2>
      <canvas id="audioCanvas"></canvas>
      <div class="stat" id="audioStatus">Click Start Mic to visualize your sound.</div>
      <div class="controls">
        <button id="audioStart">Start Mic</button>
        <button id="audioStop" class="secondary">Stop</button>
      </div>
    </section>
  </main>
  <script>
    (() => {
      // Navigation
      const nav = document.getElementById('nav');
      const sections = {
        home: document.getElementById('home'),
        flappy: document.getElementById('flappy'),
        cps: document.getElementById('cps'),
        aim: document.getElementById('aim'),
        audio: document.getElementById('audio')
      };
      let current = 'home';
      function showSection(id) {
        if (id === current) return;
        const prev = sections[current];
        const next = sections[id];
        prev.classList.remove('active');
        prev.dispatchEvent(new CustomEvent('section:leave'));
        nav.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.target === id));
        current = id;
        next.classList.add('active');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            next.dispatchEvent(new CustomEvent('section:enter'));
          });
        });
      }
      nav.addEventListener('click', e => {
        const btn = e.target.closest('[data-target]');
        if (btn) showSection(btn.dataset.target);
      });
      sections.home.addEventListener('click', e => {
        const card = e.target.closest('.card');
        if (card) showSection(card.dataset.target);
      });
      // Live clock
      const clockEl = document.getElementById('clock');
      function updateClock() {
        const d = new Date();
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        const ss = String(d.getSeconds()).padStart(2, '0');
        clockEl.textContent = `${hh}:${mm}:${ss}`;
      }
      setInterval(updateClock, 1000);
      updateClock();
      // Flappy Bird
      const flappyCanvas = document.getElementById('flappyCanvas');
      const flappyCtx = flappyCanvas.getContext('2d');
      const flappyStartBtn = document.getElementById('flappyStart');
      const flappyPauseBtn = document.getElementById('flappyPause');
      const flappyResetBtn = document.getElementById('flappyReset');
      // Constants for Flappy Bird
      const FL_GAP = 130;         // vertical gap between top and bottom pipes
      const FL_PIPEW = 60;        // width of each pipe
      const FL_GRAVITY = 0.45;    // downward acceleration of the bird
      const FL_JUMP = -8;         // velocity imparted on flap
      const FL_SPEED = 2;         // horizontal speed of pipes
      const FL_SPACING = 200;     // horizontal distance between consecutive pipes
      // Game state object.  Keeps track of whether the game is running,
      // the current animation frame id, the bird, pipes, score and best
      const flappyGame = {
        running: false,
        frameId: null,
        bird: null,
        pipes: null,
        score: 0,
        best: +(localStorage.getItem('flappyBest') || 0)
      };
      // Resize the canvas to a sensible width.  If the parent has no
      // width (when hidden), fall back to 600px.  Height is fixed.
      function flappyResize() {
        const parentWidth = flappyCanvas.parentElement.clientWidth;
        const w = parentWidth && parentWidth > 0 ? Math.min(600, parentWidth) : 600;
        flappyCanvas.width = w;
        flappyCanvas.height = 400;
      }
      // Initialise a new game (but do not start the loop).  Create the
      // bird and a starting set of pipes spaced evenly across the width
      // of the canvas.  Reset the score.  Finally draw the initial
      // scene.
      function flappyInit() {
        const h = flappyCanvas.height;
        flappyGame.bird = { x: 80, y: h / 2, vy: 0 };
        flappyGame.score = 0;
        // create an array of pipes.  Each pipe has an x position, a
        // gap centre y coordinate and a scored flag indicating whether
        // the bird has already earned a point for passing it.
        flappyGame.pipes = [];
        // start with three pipes spaced across the canvas
        // position the first pipe just beyond the right edge.  Using a
        // smaller offset makes the first pipe arrive sooner which
        // improves perceived responsiveness when starting a new game.
        const initialX = flappyCanvas.width + 80;
        for (let i = 0; i < 3; i++) {
          const gapY = 100 + Math.random() * (h - 200);
          flappyGame.pipes.push({ x: initialX + i * FL_SPACING, gapY, scored: false });
        }
        flappyDraw();
      }
      // Update the game state for one frame: apply gravity to the bird,
      // update its position, move pipes left, spawn new pipes when
      // necessary, handle collisions and update the score.  If a
      // collision occurs, stop the game.
      function flappyUpdate() {
        const bird = flappyGame.bird;
        const h = flappyCanvas.height;
        bird.vy += FL_GRAVITY;
        bird.y += bird.vy;
        // check collision with top/bottom
        if (bird.y + 10 >= h || bird.y - 10 <= 0) {
          flappyGameOver();
          return;
        }
        // update pipes
        for (const pipe of flappyGame.pipes) {
          pipe.x -= FL_SPEED;
        }
        // remove pipes that have gone off screen and generate new ones
        if (flappyGame.pipes.length && flappyGame.pipes[0].x + FL_PIPEW < 0) {
          flappyGame.pipes.shift();
          const lastX = flappyGame.pipes[flappyGame.pipes.length - 1].x;
          const gapY = 100 + Math.random() * (h - 200);
          flappyGame.pipes.push({ x: lastX + FL_SPACING, gapY, scored: false });
        }
        // scoring and collision detection
        for (const pipe of flappyGame.pipes) {
          // award point when pipe has passed the bird
          if (!pipe.scored && pipe.x + FL_PIPEW < flappyGame.bird.x) {
            pipe.scored = true;
            flappyGame.score++;
            if (flappyGame.score > flappyGame.best) {
              flappyGame.best = flappyGame.score;
              localStorage.setItem('flappyBest', flappyGame.best);
            }
          }
          // check collision: bird intersects pipe horizontally
          if (bird.x + 10 > pipe.x && bird.x - 10 < pipe.x + FL_PIPEW) {
            // check vertical overlap outside the gap
            if (bird.y - 10 < pipe.gapY - FL_GAP / 2 || bird.y + 10 > pipe.gapY + FL_GAP / 2) {
              flappyGameOver();
              return;
            }
          }
        }
      }
      // Draw the current game state onto the canvas.  Pipes are drawn
      // as green rectangles and the bird as a yellow circle.  Score
      // and best are displayed in the top left.
      function flappyDraw() {
        const w = flappyCanvas.width;
        const h = flappyCanvas.height;
        flappyCtx.fillStyle = '#10131c';
        flappyCtx.fillRect(0, 0, w, h);
        // draw pipes
        flappyCtx.fillStyle = '#4caf50';
        for (const pipe of flappyGame.pipes || []) {
          flappyCtx.fillRect(pipe.x, 0, FL_PIPEW, pipe.gapY - FL_GAP / 2);
          flappyCtx.fillRect(pipe.x, pipe.gapY + FL_GAP / 2, FL_PIPEW, h - (pipe.gapY + FL_GAP / 2));
        }
        // draw bird
        if (flappyGame.bird) {
          flappyCtx.fillStyle = '#ffeb3b';
          flappyCtx.beginPath();
          flappyCtx.arc(flappyGame.bird.x, flappyGame.bird.y, 10, 0, Math.PI * 2);
          flappyCtx.fill();
        }
        // draw scores
        flappyCtx.fillStyle = '#fff';
        flappyCtx.font = '20px sans-serif';
        flappyCtx.fillText(`Score: ${flappyGame.score}`, 10, 25);
        flappyCtx.fillText(`Best: ${flappyGame.best}`, 10, 50);
      }
      // Main loop for the game.  If running, update and redraw then
      // request the next frame.
      function flappyLoop() {
        if (!flappyGame.running) return;
        flappyUpdate();
        if (!flappyGame.running) return;
        flappyDraw();
        flappyGame.frameId = requestAnimationFrame(flappyLoop);
      }
      // Start a new game.  Resize and initialise then begin the
      // animation loop.
      function flappyStart() {
        if (flappyGame.running) return;
        flappyResize();
        flappyInit();
        flappyGame.running = true;
        flappyGame.frameId = requestAnimationFrame(flappyLoop);
      }
      // Pause the game loop without resetting the state.
      function flappyPause() {
        if (!flappyGame.running) return;
        flappyGame.running = false;
        cancelAnimationFrame(flappyGame.frameId);
      }
      // Reset the game to its initial state and draw it.  This does
      // not start the loop; it simply prepares the board for a fresh
      // start.
      function flappyReset() {
        flappyPause();
        flappyResize();
        flappyInit();
      }
      // Apply a jump impulse to the bird when clicking or pressing
      // space.  Only applies if the game is running.
      function flappyJump() {
        if (flappyGame.running && flappyGame.bird) {
          flappyGame.bird.vy = FL_JUMP;
        }
      }
      // Handle game over: pause the loop, draw the final frame and
      // overlay a translucent panel with the score and best.
      function flappyGameOver() {
        flappyPause();
        flappyDraw();
        flappyCtx.fillStyle = 'rgba(0,0,0,0.6)';
        flappyCtx.fillRect(0, 0, flappyCanvas.width, flappyCanvas.height);
        flappyCtx.fillStyle = '#fff';
        flappyCtx.font = '28px sans-serif';
        flappyCtx.fillText('Game Over', flappyCanvas.width / 2 - 70, flappyCanvas.height / 2 - 20);
        flappyCtx.font = '20px sans-serif';
        flappyCtx.fillText(`Score: ${flappyGame.score}`, flappyCanvas.width / 2 - 40, flappyCanvas.height / 2 + 10);
        flappyCtx.fillText(`Best: ${flappyGame.best}`, flappyCanvas.width / 2 - 40, flappyCanvas.height / 2 + 35);
      }
      flappyStartBtn.addEventListener('click', flappyStart);
      flappyPauseBtn.addEventListener('click', () => { flappyGame.running ? flappyPause() : flappyStart(); });
      flappyResetBtn.addEventListener('click', flappyReset);
      flappyCanvas.addEventListener('mousedown', flappyJump);
      window.addEventListener('keydown', e => {
        if (current === 'flappy' && (e.code === 'Space' || e.code === 'ArrowUp')) {
          e.preventDefault();
          flappyJump();
        }
      });
      sections.flappy.addEventListener('section:enter', () => {
        // When entering the Flappy section we completely reset the
        // game state but do not start the game loop.  flappyReset()
        // pauses any running loop, resizes the canvas and re‑creates
        // the bird and pipes.  This ensures the canvas is always
        // drawn with valid objects and avoids errors when drawing an
        // uninitialised game.  The user can then click Start to
        // reinitialise once more and begin the loop.
        flappyReset();
      });
      sections.flappy.addEventListener('section:leave', () => {
        flappyPause();
      });
      // CPS Tester
      const cpsArea = document.getElementById('cpsArea');
      const cpsStats = document.getElementById('cpsStats');
      let cpsClicks = 0;
      let cpsStartTime = 0;
      let cpsTimer = null;
      let cpsRunning = false;
      let cpsBest = +(localStorage.getItem('cpsBest') || 0);
      function cpsStart() {
        cpsClicks = 0;
        cpsRunning = true;
        cpsStartTime = performance.now();
        cpsArea.classList.add('active');
        cpsArea.textContent = 'Click!';
        cpsStats.textContent = '';
        cpsTimer = setTimeout(cpsStop, 5000);
      }
      function cpsStop() {
        cpsRunning = false;
        cpsArea.classList.remove('active');
        cpsArea.textContent = 'Click to start again';
        clearTimeout(cpsTimer);
        const dur = (performance.now() - cpsStartTime) / 1000;
        const cps = (cpsClicks / dur).toFixed(2);
        if (+cps > cpsBest) {
          cpsBest = cps;
          localStorage.setItem('cpsBest', cpsBest);
        }
        cpsStats.innerHTML = `<div>CPS: <strong>${cps}</strong></div><small>Best: ${cpsBest}</small>`;
      }
      cpsArea.addEventListener('mousedown', e => {
        e.preventDefault();
        if (!cpsRunning) {
          cpsStart();
        } else {
          cpsClicks++;
        }
      });
      sections.cps.addEventListener('section:enter', () => {
        cpsArea.textContent = 'Click to start';
        cpsStats.textContent = '';
      });
      // Aim Trainer
      const aimCanvas = document.getElementById('aimCanvas');
      const aimCtx = aimCanvas.getContext('2d');
      const aimStats = document.getElementById('aimStats');
      const aimStartBtn = document.getElementById('aimStart');
      const aimResetBtn = document.getElementById('aimReset');
      let aimRunning = false;
      let aimTargets = [];
      let aimIndex = 0;
      let aimHits = 0;
      let aimMiss = 0;
      let aimTimes = [];
      let aimBest = JSON.parse(localStorage.getItem('aimBest') || 'null');
      function aimResize() {
        const parentWidth = aimCanvas.parentElement.clientWidth || 600;
        aimCanvas.width = Math.min(600, parentWidth);
        aimCanvas.height = 400;
      }
      function aimDraw() {
        const w = aimCanvas.width;
        const h = aimCanvas.height;
        aimCtx.fillStyle = '#10131c';
        aimCtx.fillRect(0, 0, w, h);
        if (aimRunning && aimIndex < aimTargets.length) {
          const t = aimTargets[aimIndex];
          aimCtx.fillStyle = '#e91e63';
          aimCtx.beginPath();
          aimCtx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
          aimCtx.fill();
        }
        aimCtx.fillStyle = '#fff';
        aimCtx.font = '18px sans-serif';
        aimCtx.fillText(`Hits: ${aimHits}/${aimIndex}`, 10, 20);
      }
      function aimSpawn() {
        if (aimIndex >= 30) {
          aimEnd();
          return;
        }
        const r = 20;
        const w = aimCanvas.width;
        const h = aimCanvas.height;
        const x = Math.random() * (w - 2 * r) + r;
        const y = Math.random() * (h - 2 * r) + r;
        aimTargets[aimIndex] = { x, y, r, spawnTime: performance.now() };
        aimDraw();
      }
      function aimClick(e) {
        if (!aimRunning) return;
        const rect = aimCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const t = aimTargets[aimIndex];
        const dx = x - t.x;
        const dy = y - t.y;
        if (Math.hypot(dx, dy) <= t.r) {
          const rt = performance.now() - t.spawnTime;
          aimTimes.push(rt);
          aimHits++;
          aimIndex++;
          aimSpawn();
        } else {
          aimMiss++;
        }
      }
      function aimEnd() {
        aimRunning = false;
        aimCanvas.removeEventListener('mousedown', aimClick);
        const avg = aimTimes.reduce((a, b) => a + b, 0) / aimTimes.length || 0;
        const acc = aimHits / (aimHits + aimMiss);
        let best = aimBest;
        if (!best || avg < best.avg) {
          best = { avg, acc };
          aimBest = best;
          localStorage.setItem('aimBest', JSON.stringify(best));
        }
        aimStats.innerHTML = `<div>Average: <strong>${avg.toFixed(0)}</strong> ms</div><div>Accuracy: <strong>${(acc * 100).toFixed(0)}%</strong></div><small>Best avg: ${best.avg.toFixed(0)} ms, Acc: ${(best.acc * 100).toFixed(0)}%</small>`;
      }
      function aimStartGame() {
        if (aimRunning) return;
        aimRunning = true;
        aimIndex = 0;
        aimHits = 0;
        aimMiss = 0;
        aimTimes = [];
        aimTargets = new Array(30);
        aimStats.textContent = '';
        aimResize();
        aimSpawn();
        aimCanvas.addEventListener('mousedown', aimClick);
      }
      aimStartBtn.addEventListener('click', aimStartGame);
      aimResetBtn.addEventListener('click', () => {
        aimRunning = false;
        aimCanvas.removeEventListener('mousedown', aimClick);
        aimStats.textContent = '';
        aimDraw();
      });
      sections.aim.addEventListener('section:enter', () => {
        aimResize();
        aimDraw();
      });
      sections.aim.addEventListener('section:leave', () => {
        aimRunning = false;
        aimCanvas.removeEventListener('mousedown', aimClick);
      });
      // Audio Visualizer
      const audioCanvas = document.getElementById('audioCanvas');
      const audioCtx2 = audioCanvas.getContext('2d');
      const audioStatus = document.getElementById('audioStatus');
      const audioStartBtn = document.getElementById('audioStart');
      const audioStopBtn = document.getElementById('audioStop');
      let audioAudioCtx = null;
      let audioAnalyser = null;
      let audioDataArray = null;
      let audioRAF = null;
      let audioStream = null;
      function audioResize() {
        const parentWidth = audioCanvas.parentElement.clientWidth || 600;
        audioCanvas.width = Math.min(600, parentWidth);
        audioCanvas.height = 300;
      }
      function audioDraw() {
        const w = audioCanvas.width;
        const h = audioCanvas.height;
        audioCtx2.clearRect(0, 0, w, h);
        if (!audioAnalyser) {
          audioCtx2.fillStyle = '#555';
          audioCtx2.fillRect(0, 0, w, h);
          return;
        }
        audioAnalyser.getByteFrequencyData(audioDataArray);
        const barWidth = w / audioDataArray.length * 2.5;
        let x = 0;
        for (let i = 0; i < audioDataArray.length; i++) {
          const v = audioDataArray[i] / 255;
          const barHeight = v * h;
          const hue = (i / audioDataArray.length) * 360;
          audioCtx2.fillStyle = `hsl(${hue},70%,50%)`;
          audioCtx2.fillRect(x, h - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
        audioRAF = requestAnimationFrame(audioDraw);
      }
      async function audioStart() {
        if (audioAnalyser) return;
        audioResize();
        try {
          audioAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioStream = stream;
          const source = audioAudioCtx.createMediaStreamSource(stream);
          audioAnalyser = audioAudioCtx.createAnalyser();
          audioAnalyser.fftSize = 256;
          const bufferLength = audioAnalyser.frequencyBinCount;
          audioDataArray = new Uint8Array(bufferLength);
          source.connect(audioAnalyser);
          audioStatus.innerHTML = '<strong>Live Mode</strong>: Audio bars respond to your mic';
          audioDraw();
        } catch (err) {
          console.log(err);
          audioStatus.innerHTML = 'Microphone unavailable – using demo mode';
          audioAnalyser = null;
          cancelAnimationFrame(audioRAF);
          const w = audioCanvas.width;
          const h = audioCanvas.height;
          let t = 0;
          function demo() {
            audioCtx2.clearRect(0, 0, w, h);
            for (let i = 0; i < 60; i++) {
              const val = (Math.sin((i + t) / 5) + 1) / 2;
              const bw = w / 60;
              audioCtx2.fillStyle = `hsl(${(i * 5 + t) % 360},70%,50%)`;
              audioCtx2.fillRect(i * bw, h - val * h, bw - 2, val * h);
            }
            t += 0.5;
            audioRAF = requestAnimationFrame(demo);
          }
          demo();
        }
      }
      function audioStop() {
        if (audioRAF) cancelAnimationFrame(audioRAF);
        if (audioAudioCtx) {
          audioAudioCtx.close();
          audioAudioCtx = null;
        }
        if (audioStream) {
          audioStream.getTracks().forEach(t => t.stop());
          audioStream = null;
        }
        audioAnalyser = null;
        audioStatus.innerHTML = 'Click Start Mic to visualize your sound.';
        audioCtx2.clearRect(0, 0, audioCanvas.width, audioCanvas.height);
      }
      audioStartBtn.addEventListener('click', audioStart);
      audioStopBtn.addEventListener('click', audioStop);
      sections.audio.addEventListener('section:enter', () => {
        audioResize();
        audioDraw();
      });
      sections.audio.addEventListener('section:leave', () => {
        audioStop();
      });
    })();
  </script>
</body>
</html>